---
---

asyncio가 좋다; 코드 베이스를 점진적으로 마이그레이션 할 때 - 블로킹 IO - 스레드 & 비동기 IO - 코루틴 공존해야 함.
하향식, 상향식으로 스레드 기반 구현 -> 점진적으로 asyncio와 코루틴 기반으로 바꿀 수 있다.

-------------------
하향식:
1. 최상위 함수가 async def를 사용하도록
2. 최상위 함수에서 IO를 호출하는 모둔 부분을 asyncio.run_in_executor로 감싼다.
3. asyncio.run_in_executor 호출이 사용하는 자원이나 콜백이 제대로 '동기화' 됐는지 확인
4. 호출 계층의 잎쪽으로 내려가며 중간에 있는 함수와 메소드를 코루틴으로 변환하며 asyncio.run_in_executor나 get_event_loop 호출 없애기

run_in_executor: 이벤트 루프가 특정 ThreadPoolExecutorsk 디폴트 실행기 인스턴스를 사용해 주어진 함수를 실행하게 만든다.

너무 많은 블로킹 파일 IO 연산을 사용할 떄는
asyncio로 포팅하기에도 코드의 명확성이 떨어지고 성능을 저하시킨다는 단점이 있다.

------------


상향식:
1. 프로그램 잎 부분에 있는 포팅하려는 함수의 비동기 코루틴 버전 새로 만들기
2. 기존 동기 함수 변경해서 코루틴 버전을 호출하고 실제 동작을 구현하는 대신 이벤트 루프 실행
3. 호출 계층을 한단계 올려서 다른 코루틴 계층을 만들고, 기존 동기적 함수 호출하는 부분에서 1단계에서 정의한 코루틴 호출로 바꾸기
4. 비동기 부분을 결합하기 위해 2단계에서 만든 동기적인 래퍼 삭제하기


asyncio 이벤트 루프의 run_until_complete 메소드를 통해 동기적인 코드가 코루틴을 호출하고 완료를 기다릴 수 있다.

